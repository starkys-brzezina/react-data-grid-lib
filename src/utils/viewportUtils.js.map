{"version":3,"file":"viewportUtils.js","sourceRoot":"","sources":["viewportUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { isFrozen } from '../ColumnUtils';\nimport { SCROLL_DIRECTION } from '../common/enums';\nimport { CalculatedColumn, ColumnMetrics } from '../common/types';\n\nexport const OVERSCAN_ROWS = 2;\n\nconst { min, max, ceil, round } = Math;\n\nexport function getGridState(props: { columnMetrics: ColumnMetrics; rowsCount: number; minHeight: number; rowHeight: number; rowOffsetHeight: number }) {\n  const totalNumberColumns = props.columnMetrics.columns.length;\n  const canvasHeight = props.minHeight - props.rowOffsetHeight;\n  const renderedRowsCount = ceil((props.minHeight - props.rowHeight) / props.rowHeight);\n  const rowOverscanEndIdx = min(props.rowsCount, renderedRowsCount * 2);\n\n  return {\n    rowOverscanStartIdx: 0,\n    rowOverscanEndIdx,\n    rowVisibleStartIdx: 0,\n    rowVisibleEndIdx: renderedRowsCount,\n    height: canvasHeight,\n    scrollTop: 0,\n    scrollLeft: 0,\n    colVisibleStartIdx: 0,\n    colVisibleEndIdx: totalNumberColumns,\n    colOverscanStartIdx: 0,\n    colOverscanEndIdx: totalNumberColumns,\n    isScrolling: false,\n    lastFrozenColumnIndex: 0\n  };\n}\n\nexport function findLastFrozenColumnIndex(columns: CalculatedColumn[]): number {\n  return columns.findIndex(c => isFrozen(c));\n}\n\nfunction getTotalFrozenColumnWidth(columns: CalculatedColumn[]): number {\n  const lastFrozenColumnIndex = findLastFrozenColumnIndex(columns);\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n  const lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nfunction getColumnCountForWidth(columns: CalculatedColumn[], initialWidth: number, colVisibleStartIdx: number): number {\n  let width = initialWidth;\n  let count = 0;\n\n  columns.forEach((column, idx) => {\n    if (idx! >= colVisibleStartIdx) {\n      width -= column.width;\n      if (width >= 0) {\n        count++;\n      }\n    }\n  });\n\n  return count;\n}\n\nexport function getNonFrozenVisibleColStartIdx(columns: CalculatedColumn[], scrollLeft: number): number {\n  let remainingScroll = scrollLeft;\n  const lastFrozenColumnIndex = findLastFrozenColumnIndex(columns);\n  const nonFrozenColumns = columns.slice(lastFrozenColumnIndex + 1);\n  let columnIndex = lastFrozenColumnIndex;\n  while (remainingScroll >= 0 && columnIndex < nonFrozenColumns.length) {\n    columnIndex++;\n    const column = columns[columnIndex];\n    remainingScroll -= column ? column.width : 0;\n  }\n  return max(columnIndex, 0);\n}\n\nexport function getNonFrozenRenderedColumnCount(columnMetrics: ColumnMetrics, viewportDomWidth: number, scrollLeft: number): number {\n  const { columns, totalColumnWidth } = columnMetrics;\n  if (columns.length === 0) {\n    return 0;\n  }\n  const colVisibleStartIdx = getNonFrozenVisibleColStartIdx(columns, scrollLeft);\n  const totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns);\n  const viewportWidth = viewportDomWidth > 0 ? viewportDomWidth : totalColumnWidth;\n  const firstColumn = columns[colVisibleStartIdx];\n  // calculate the portion width of first column hidden behind frozen columns\n  const scrolledFrozenWidth = totalFrozenColumnWidth + scrollLeft;\n  const firstColumnHiddenWidth = scrolledFrozenWidth > firstColumn.left ? scrolledFrozenWidth - firstColumn.left : 0;\n  const initialWidth = viewportWidth - totalFrozenColumnWidth + firstColumnHiddenWidth;\n  return getColumnCountForWidth(columns, initialWidth, colVisibleStartIdx);\n}\n\nexport interface VisibleBoundaries {\n  rowVisibleStartIdx: number;\n  rowVisibleEndIdx: number;\n}\n\nexport function getVisibleBoundaries(gridHeight: number, rowHeight: number, scrollTop: number, rowsCount: number): VisibleBoundaries {\n  const renderedRowsCount = ceil(gridHeight / rowHeight);\n  const rowVisibleStartIdx = max(0, round(scrollTop / rowHeight));\n  const rowVisibleEndIdx = min(rowVisibleStartIdx + renderedRowsCount, rowsCount);\n  return { rowVisibleStartIdx, rowVisibleEndIdx };\n}\n\ninterface ScrollState {\n  scrollTop?: number;\n  scrollLeft?: number;\n}\n\nexport function getScrollDirection(lastScroll: ScrollState, scrollTop: number, scrollLeft: number): SCROLL_DIRECTION {\n  if (scrollTop !== lastScroll.scrollTop && lastScroll.scrollTop !== undefined) {\n    return scrollTop - lastScroll.scrollTop >= 0 ? SCROLL_DIRECTION.DOWN : SCROLL_DIRECTION.UP;\n  }\n  if (scrollLeft !== lastScroll.scrollLeft && lastScroll.scrollLeft !== undefined) {\n    return scrollLeft - lastScroll.scrollLeft >= 0 ? SCROLL_DIRECTION.RIGHT : SCROLL_DIRECTION.LEFT;\n  }\n  return SCROLL_DIRECTION.NONE;\n}\n\nexport function getRowOverscanStartIdx(scrollDirection: SCROLL_DIRECTION, rowVisibleStartIdx: number): number {\n  return scrollDirection === SCROLL_DIRECTION.UP ? max(0, rowVisibleStartIdx - OVERSCAN_ROWS) : max(0, rowVisibleStartIdx);\n}\n\nexport function getRowOverscanEndIdx(scrollDirection: SCROLL_DIRECTION, rowVisibleEndIdx: number, rowsCount: number): number {\n  if (scrollDirection === SCROLL_DIRECTION.DOWN) {\n    const overscanBoundaryIdx = rowVisibleEndIdx + OVERSCAN_ROWS;\n    return min(overscanBoundaryIdx, rowsCount);\n  }\n  return rowVisibleEndIdx;\n}\n\nexport function getColOverscanStartIdx(scrollDirection: SCROLL_DIRECTION, colVisibleStartIdx: number, lastFrozenColumnIdx: number): number {\n  if (scrollDirection === SCROLL_DIRECTION.LEFT || scrollDirection === SCROLL_DIRECTION.RIGHT) {\n    return lastFrozenColumnIdx > -1 ? lastFrozenColumnIdx + 1 : 0;\n  }\n  return colVisibleStartIdx;\n}\n\nexport function getColOverscanEndIdx(scrollDirection: SCROLL_DIRECTION, colVisibleEndIdx: number, totalNumberColumns: number): number {\n  if (scrollDirection === SCROLL_DIRECTION.DOWN || scrollDirection === SCROLL_DIRECTION.UP) {\n    return colVisibleEndIdx;\n  }\n  return totalNumberColumns;\n}\n"]}