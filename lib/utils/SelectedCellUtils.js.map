{"version":3,"file":"SelectedCellUtils.js","sourceRoot":"","sources":["../../src/utils/SelectedCellUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { CellNavigationMode, Z_INDEXES } from '../common/enums';\nimport * as rowUtils from '../RowUtils';\nimport { isFrozen, canEdit } from '../ColumnUtils';\nimport { CalculatedColumn, Position, Range, Dimension, RowGetter, RowData } from '../common/types';\n\nconst getRowTop = (rowIdx: number, rowHeight: number): number => rowIdx * rowHeight;\n\ninterface getSelectedRowOpts {\n  selectedPosition: Position;\n  rowGetter: RowGetter;\n}\n\nexport function getSelectedRow({ selectedPosition, rowGetter }: getSelectedRowOpts): RowData {\n  return rowGetter(selectedPosition.rowIdx);\n}\n\ninterface getSelectedDimensionsOpts {\n  selectedPosition: Position;\n  columns: CalculatedColumn[];\n  rowHeight: number;\n  scrollLeft: number;\n}\n\nexport function getSelectedDimensions({ selectedPosition: { idx, rowIdx }, columns, rowHeight, scrollLeft }: getSelectedDimensionsOpts): Dimension {\n  if (idx < 0) {\n    return { width: 0, left: 0, top: 0, height: rowHeight, zIndex: 1 };\n  }\n  const column = columns[idx];\n  const frozen = isFrozen(column);\n  const { width } = column;\n  const left = frozen ? column.left + scrollLeft : column.left;\n  const top = getRowTop(rowIdx, rowHeight);\n  const zIndex = frozen ? Z_INDEXES.FROZEN_CELL_MASK : Z_INDEXES.CELL_MASK;\n  return { width, left, top, height: rowHeight, zIndex };\n}\n\ninterface getSelectedRangeDimensionsOpts {\n  selectedRange: Range;\n  columns: CalculatedColumn[];\n  rowHeight: number;\n}\n\nexport function getSelectedRangeDimensions({ selectedRange: { topLeft, bottomRight }, columns, rowHeight }: getSelectedRangeDimensionsOpts): Dimension {\n  if (topLeft.idx < 0) {\n    return { width: 0, left: 0, top: 0, height: rowHeight, zIndex: Z_INDEXES.CELL_MASK };\n  }\n\n  let width = 0;\n  let anyColFrozen = false;\n  for (let i = topLeft.idx; i <= bottomRight.idx; i++) {\n    const column = columns[i];\n    width += column.width;\n    anyColFrozen = anyColFrozen || isFrozen(column);\n  }\n\n  const { left } = columns[topLeft.idx];\n  const top = getRowTop(topLeft.rowIdx, rowHeight);\n  const height = (bottomRight.rowIdx - topLeft.rowIdx + 1) * rowHeight;\n  const zIndex = anyColFrozen ? Z_INDEXES.FROZEN_CELL_MASK : Z_INDEXES.CELL_MASK;\n\n  return { width, left, top, height, zIndex };\n}\n\ninterface getSelectedColumnOpts {\n  selectedPosition: Position;\n  columns: CalculatedColumn[];\n}\n\nexport function getSelectedColumn({ selectedPosition, columns }: getSelectedColumnOpts): CalculatedColumn {\n  return columns[selectedPosition.idx];\n}\n\ninterface getSelectedCellValueOpts {\n  selectedPosition: Position;\n  columns: CalculatedColumn[];\n  rowGetter: RowGetter;\n}\n\nexport function getSelectedCellValue({ selectedPosition, columns, rowGetter }: getSelectedCellValueOpts) {\n  const column = getSelectedColumn({ selectedPosition, columns });\n  const row = getSelectedRow({ selectedPosition, rowGetter });\n\n  return row && column ? rowUtils.get(row, column.key) : null;\n}\n\ninterface isSelectedCellEditableOpts {\n  enableCellSelect: boolean;\n  selectedPosition: Position;\n  columns: CalculatedColumn[];\n  rowGetter: RowGetter;\n  onCheckCellIsEditable?(arg: { row: any; column: CalculatedColumn } & Position): boolean;\n}\n\nexport function isSelectedCellEditable({ enableCellSelect, selectedPosition, columns, rowGetter, onCheckCellIsEditable }: isSelectedCellEditableOpts): boolean {\n  const column = getSelectedColumn({ selectedPosition, columns });\n  const row = getSelectedRow({ selectedPosition, rowGetter });\n  const isCellEditable = onCheckCellIsEditable ? onCheckCellIsEditable({ row, column, ...selectedPosition }) : true;\n  return isCellEditable && canEdit(column, row, enableCellSelect);\n}\n\ninterface getNextSelectedCellPositionOpts {\n  cellNavigationMode: CellNavigationMode;\n  columns: CalculatedColumn[];\n  rowsCount: number;\n  nextPosition: Position;\n}\n\nexport interface NextSelectedCellPosition extends Position {\n  changeRowOrColumn: boolean;\n}\n\nexport function getNextSelectedCellPosition({ cellNavigationMode, columns, rowsCount, nextPosition }: getNextSelectedCellPositionOpts): NextSelectedCellPosition {\n  if (cellNavigationMode !== CellNavigationMode.NONE) {\n    const { idx, rowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isLastRow = rowIdx === rowsCount - 1;\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1,\n            changeRowOrColumn: true\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: 0,\n          changeRowOrColumn: true\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isFirstRow = rowIdx === 0;\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1,\n            changeRowOrColumn: true\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: columnsCount - 1,\n          changeRowOrColumn: true\n        };\n      }\n    }\n  }\n\n  return { ...nextPosition, changeRowOrColumn: false };\n}\n\ninterface canExitGridOpts {\n  cellNavigationMode: CellNavigationMode;\n  columns: CalculatedColumn[];\n  rowsCount: number;\n  selectedPosition: Position;\n}\n\nexport function canExitGrid(event: React.KeyboardEvent, { cellNavigationMode, columns, rowsCount, selectedPosition: { rowIdx, idx } }: canExitGridOpts): boolean {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === CellNavigationMode.NONE || cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n    const shift = event.shiftKey === true;\n\n    return shift ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n\nexport function selectedRangeIsSingleCell({ topLeft, bottomRight }: Range): boolean {\n  return topLeft.idx === bottomRight.idx && topLeft.rowIdx === bottomRight.rowIdx;\n}\n"]}